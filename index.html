<html>
<head>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->

</head>
 <meta charset="utf-8">
 <style>


 .graticule {
   fill: none;
   stroke: #777;
   stroke-width: 0.5px;
   stroke-opacity: 0.5;
 }

 .land {
   fill: #222;
 }

 .boundary {
   fill: none;
   stroke: #fff;
   stroke-width: 0.5px;
 }

 </style>
<body>
<nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Brand</a>
    </div>

    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="active"><a href="#">Link <span class="sr-only">(current)</span></a></li>
        <li><a href="#">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Dropdown <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li class="divider"></li>
            <li><a href="#">Separated link</a></li>
            <li class="divider"></li>
            <li><a href="#">One more separated link</a></li>
          </ul>
        </li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#">Link</a></li>
      </ul>
    </div>
  </div>
</nav>

<h1>Hello, world!</h1>

<div id="maincontent" class="container">
</div>

 </body>
 <script src="https://d3js.org/d3.v4.min.js"></script>
 <script>

     // var n = 4, // The number of series.
     //     m = 58; // The number of values per series.
     //
     // // The xz array has m elements, representing the x-values shared by all series.
     // // The yz array has n elements, representing the y-values of each of the n series.
     // // Each yz[i] is an array of m non-negative numbers representing a y-value for xz[i].
     // // The y01z array has the same structure as yz, but with stacked [y₀, y₁] instead of y.
     // var xz = d3.range(m),
     //     yz = d3.range(n).map(function() { return bumps(m); }),
     //     y01z = d3.stack().keys(d3.range(n))(d3.transpose(yz)),
     //     yMax = d3.max(yz, function(y) { return d3.max(y); }),
     //     y1Max = d3.max(y01z, function(y) { return d3.max(y, function(d) { return d[1]; }); });
     //
     // var svg = d3.select("svg"),
     //     margin = {top: 40, right: 10, bottom: 20, left: 10},
     //     width = +svg.attr("width") - margin.left - margin.right,
     //     height = +svg.attr("height") - margin.top - margin.bottom,
     //     g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
     //
     // var x = d3.scaleBand()
     //     .domain(xz)
     //     .rangeRound([0, width])
     //     .padding(0.08);
     //
     // var y = d3.scaleLinear()
     //     .domain([0, y1Max])
     //     .range([height, 0]);
     //
     // var color = d3.scaleOrdinal()
     //     .domain(d3.range(n))
     //     .range(d3.schemeCategory20c);
     //
     // var series = g.selectAll(".series")
     //   .data(y01z)
     //   .enter().append("g")
     //     .attr("fill", function(d, i) { return color(i); });
     //
     // var rect = series.selectAll("rect")
     //   .data(function(d) { return d; })
     //   .enter().append("rect")
     //     .attr("x", function(d, i) { return x(i); })
     //     .attr("y", height)
     //     .attr("width", x.bandwidth())
     //     .attr("height", 0);
     //
     // rect.transition()
     //     .delay(function(d, i) { return i * 10; })
     //     .attr("y", function(d) { return y(d[1]); })
     //     .attr("height", function(d) { return y(d[0]) - y(d[1]); });
     //
     // g.append("g")
     //     .attr("class", "axis axis--x")
     //     .attr("transform", "translate(0," + height + ")")
     //     .call(d3.axisBottom(x)
     //         .tickSize(0)
     //         .tickPadding(6));
     //
     // d3.selectAll("input")
     //     .on("change", changed);
     //
     // var timeout = d3.timeout(function() {
     //   d3.select("input[value=\"grouped\"]")
     //       .property("checked", true)
     //       .dispatch("change");
     // }, 2000);
     //
     // function changed() {
     //   timeout.stop();
     //   if (this.value === "grouped") transitionGrouped();
     //   else transitionStacked();
     // }
     //
     // function transitionGrouped() {
     //   y.domain([0, yMax]);
     //
     //   rect.transition()
     //       .duration(500)
     //       .delay(function(d, i) { return i * 10; })
     //       .attr("x", function(d, i) { return x(i) + x.bandwidth() / n * this.parentNode.__data__.key; })
     //       .attr("width", x.bandwidth() / n)
     //     .transition()
     //       .attr("y", function(d) { return y(d[1] - d[0]); })
     //       .attr("height", function(d) { return y(0) - y(d[1] - d[0]); });
     // }
     //
     // function transitionStacked() {
     //   y.domain([0, y1Max]);
     //
     //   rect.transition()
     //       .duration(500)
     //       .delay(function(d, i) { return i * 10; })
     //       .attr("y", function(d) { return y(d[1]); })
     //       .attr("height", function(d) { return y(d[0]) - y(d[1]); })
     //     .transition()
     //       .attr("x", function(d, i) { return x(i); })
     //       .attr("width", x.bandwidth());
     // }
     //
     // // Returns an array of m psuedorandom, smoothly-varying non-negative numbers.
     // // Inspired by Lee Byron’s test data generator.
     // // http://leebyron.com/streamgraph/
     // function bumps(m) {
     //   var values = [], i, j, w, x, y, z;
     //
     //   // Initialize with uniform random values in [0.1, 0.2).
     //   for (i = 0; i < m; ++i) {
     //     values[i] = 0.1 + 0.1 * Math.random();
     //   }
     //
     //   // Add five random bumps.
     //   for (j = 0; j < 5; ++j) {
     //     x = 1 / (0.1 + Math.random());
     //     y = 2 * Math.random() - 0.5;
     //     z = 10 / (0.1 + Math.random());
     //     for (i = 0; i < m; i++) {
     //       w = (i / m - y) * z;
     //       values[i] += x * Math.exp(-w * w);
     //     }
     //   }
     //
     //   // Ensure all values are positive.
     //   for (i = 0; i < m; ++i) {
     //     values[i] = Math.max(0, values[i]);
     //   }
     //
     //   return values;
     // }

 </script>
 <script src="static/js/jquery-3.2.1.min.js"></script>
 <!-- Latest compiled and minified JavaScript -->
 <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
 <script src="https://d3js.org/d3-array.v1.min.js"></script>
 <script src="https://d3js.org/d3-geo.v1.min.js"></script>
 <script src="https://d3js.org/topojson.v1.min.js"></script>
 <script src="https://unpkg.com/topojson@3"></script>
 <script>
 var width = 960,
     height = 600;

 var projection = d3.geoAlbersUsa()
     .scale(1280)
     .translate([width / 2, height / 2]);

 var path = d3.geoPath()
     .projection(projection);

 var color = d3.scaleOrdinal(d3.schemeCategory10);.domain(d3.range(9)),
     selectedColor = 0,
     dragColor;

 var components = color.domain().map(function() { return []; });

 var svg = d3.select("body").append("svg")
     .attr("width", width)
     .attr("height", height);

 var legend = svg.append("g")
     .attr("class", "legend")
     .attr("transform", "translate(" + ((width - color.domain().length * 24) / 2) + ",10)")
     .style("cursor", "pointer")
   .selectAll("rect")
     .data(color.domain())
   .enter().append("rect")
     .attr("x", function(d) { return d * 24; })
     .attr("width", 24 - 3)
     .attr("height", 24 - 3)
     .style("stroke", function(d) { return d ? null : "#000"; })
     .style("fill", color)
     .on("click", clicklegend);

 d3.select(self)
     .on("keydown", keydown)
     .node().focus();

 d3.json("./mapdata/us2016.topo.json", function(error, us) {
   if (error) throw error;

   var bisectId = d3.bisector(function(d) { return d.id; }).left;

   var features = topojson.feature(us, us.objects.states).features;

   svg.append("path")
       .datum(topojson.mesh(us, us.objects.states))
       .attr("class", "background")
       .attr("d", path);

   var merge = svg.append("g")
       .attr("class", "merge")
     .selectAll("path")
       .data(components)
     .enter().append("path")
       .style("fill", function(d, i) { return color(i); })
       .style("stroke", function(d, i) { return d3.lab(color(i)).darker(); });

   svg.append("g")
       .attr("class", "foreground")
       .style("cursor", "pointer")
       .style("stroke-opacity", .5)
     .selectAll("path")
       .data(features)
     .enter().append("path")
       .attr("d", function(d) { d.color = null; return path(d); })
       .on("mouseover", function() { this.style.stroke = "black"; })
       .on("mouseout", function() { this.style.stroke = "none"; })
       .call(d3.behavior.drag()
         .on("dragstart", dragstart)
         .on("drag", drag));

   top.location.hash.split("").slice(1, features.length).forEach(function(c, i) {
     if ((c = +c) >= 0 && c < 10) assign(features[i], c ? c - 1 : null);
   });

   redraw();

   function dragstart() {
     var feature = d3.event.sourceEvent.target.__data__;
     if (assign(feature, dragColor = feature.color === selectedColor ? null : selectedColor)) redraw();
   }

   function drag() {
     var feature = d3.event.sourceEvent.target.__data__;
     if (feature && assign(feature, dragColor)) redraw();
   }

   function assign(feature, color) {
     if (feature.color === color) return false;
     if (feature.color !== null) {
       var component = components[feature.color];
       component.splice(bisectId(component, feature.id), 1);
       feature.color = null;
     }
     if (color !== null) {
       var component = components[color];
       component.splice(bisectId(component, feature.id), 0, feature);
       feature.color = color;
     }
     return true;
   }

   function redraw() {
     merge.data(components).attr("d", function(d) { return path({type: "FeatureCollection", features: d}) || "M0,0"; });
     top.history.replaceState(null, null, "#" + features.map(function(d) { return d.color === null ? "0" : d.color + 1; }).join(""));
   }
 });

 function clicklegend(d) {
   legend[0][selectedColor].style.stroke = null;
   legend[0][selectedColor = d].style.stroke = "#000";
 }

 function keydown() {
   if (d3.event.keyCode >= 48 && d3.event.keyCode < 58) {
     var i = d3.event.keyCode - 49;
     if (i < 0) i = 10;
     clicklegend(i);
   }
 }

 d3.select(self.frameElement).style("height", height + "px");
 </script>

</html>
